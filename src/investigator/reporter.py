import logging

from shared.github_client import GitHubClient, GitHubClientError
from shared.jira_client import JiraClient, build_adf_document
from shared.models import AggregatedFindings, Repository
from shared.slack_client import SlackClient

logger = logging.getLogger(__name__)

MAX_PR_TITLE_LEN = 72
DEFAULT_JIRA_BROWSE_BASE_URL = "https://jira.example.com"


# ---------------------------------------------------------------------------
# Formatting helpers (pure, testable)
# ---------------------------------------------------------------------------


def format_pr_title(findings: AggregatedFindings) -> str:
    prefix = f"[Bug Basher] {findings.bug.jira_key}: "
    summary = findings.bug.summary
    title = prefix + summary
    if len(title) > MAX_PR_TITLE_LEN:
        title = title[: MAX_PR_TITLE_LEN - 3] + "..."
    return title


def format_pr_body(findings: AggregatedFindings) -> str:
    bug = findings.bug
    best = findings.best_result
    lines: list[str] = []

    bug_url = bug.url or f"{DEFAULT_JIRA_BROWSE_BASE_URL}/browse/{bug.jira_key}"
    lines.append(f"**Bug:** [{bug.jira_key}]({bug_url})")
    lines.append(f"**Summary:** {bug.summary}")
    lines.append("")

    if best:
        if best.root_cause:
            lines.append("## Root Cause")
            lines.append(best.root_cause)
            lines.append("")

        if best.evidence:
            lines.append("## Evidence")
            for e in best.evidence:
                lines.append(f"- {e}")
            lines.append("")

        if best.proposed_fix:
            lines.append("## Changes")
            lines.append(best.proposed_fix.description)
            for fc in best.proposed_fix.files_changed:
                lines.append(f"- `{fc.path}`")
            lines.append("")

        lines.append(f"**Confidence:** {best.confidence:.0%}")
        lines.append("")

    lines.append("---")
    lines.append("*This PR was auto-generated by Bug Basher. Please review carefully before merging.*")
    return "\n".join(lines)


def format_jira_comment(
    findings: AggregatedFindings, pr_url: str | None = None
) -> dict:
    sections: list[tuple[str, str]] = []
    best = findings.best_result
    action = findings.action

    # Repos investigated
    repos_text = ", ".join(r.repo for r in findings.results) if findings.results else "none"
    sections.append(("Repositories Investigated", repos_text))

    # Confidence
    if best:
        sections.append(("Confidence", f"{best.confidence:.0%}"))

    # Root cause / findings
    if best and best.root_cause:
        sections.append(("Root Cause", best.root_cause))

    if best and best.evidence:
        evidence_text = "\n".join(f"• {e}" for e in best.evidence)
        sections.append(("Evidence", evidence_text))

    # PR link
    if pr_url:
        sections.append(("Pull Request", pr_url))

    # Next steps for uncertain / summary actions
    if action and action.action_type in ("comment_uncertain", "comment_summary"):
        if best and best.next_steps:
            steps_text = "\n".join(f"• {s}" for s in best.next_steps)
            sections.append(("Suggested Next Steps", steps_text))
        else:
            sections.append(
                ("Suggested Next Steps", "Manual investigation recommended.")
            )

    return build_adf_document(sections)


def format_slack_message(
    findings: AggregatedFindings, pr_url: str | None = None
) -> tuple[str, list[dict]]:
    bug = findings.bug
    best = findings.best_result
    action = findings.action

    bug_url = bug.url or f"{DEFAULT_JIRA_BROWSE_BASE_URL}/browse/{bug.jira_key}"

    # Fallback text
    text = f"Bug Basher: {bug.jira_key} — {bug.summary}"

    blocks: list[dict] = [
        {
            "type": "header",
            "text": {
                "type": "plain_text",
                "text": f"Bug Basher: {bug.jira_key}",
            },
        },
        {
            "type": "section",
            "text": {
                "type": "mrkdwn",
                "text": f"*<{bug_url}|{bug.jira_key}>*: {bug.summary}",
            },
        },
    ]

    if best and action:
        confidence_text = f"{best.confidence:.0%}"
        action_text = {
            "pr": "PR Created",
            "comment_root_cause": "Root Cause Found",
            "comment_uncertain": "Uncertain",
            "comment_summary": "Summary Only",
        }.get(action.action_type, action.action_type)

        blocks.append(
            {
                "type": "section",
                "fields": [
                    {"type": "mrkdwn", "text": f"*Confidence:* {confidence_text}"},
                    {"type": "mrkdwn", "text": f"*Action:* {action_text}"},
                ],
            }
        )

    if best and best.root_cause:
        root_cause = best.root_cause
        if len(root_cause) > 200:
            root_cause = root_cause[:197] + "..."
        blocks.append(
            {
                "type": "section",
                "text": {
                    "type": "mrkdwn",
                    "text": f"*Root Cause:* {root_cause}",
                },
            }
        )

    if pr_url:
        blocks.append(
            {
                "type": "section",
                "text": {
                    "type": "mrkdwn",
                    "text": f"*PR:* <{pr_url}|View Pull Request>",
                },
            }
        )

    return text, blocks


# ---------------------------------------------------------------------------
# PR creation
# ---------------------------------------------------------------------------


async def create_pr_from_findings(
    findings: AggregatedFindings,
    repos: list[Repository],
    github_client: GitHubClient,
) -> str | None:
    """Create a PR with the proposed fix. Returns html_url or None on failure."""
    best = findings.best_result
    if not best or not best.proposed_fix or not best.proposed_fix.files_changed:
        return None

    # Find github_slug for the best result's repo
    slug = None
    for r in repos:
        if r.name == best.repo and r.github_slug:
            slug = r.github_slug
            break

    if not slug:
        logger.warning("No github_slug found for repo %s", best.repo)
        return None

    parts = slug.split("/", 1)
    if len(parts) != 2:
        logger.warning("Invalid github_slug: %s", slug)
        return None
    owner, repo_name = parts

    try:
        default_branch = await github_client.get_default_branch(owner, repo_name)
        head_sha = await github_client.get_branch_sha(owner, repo_name, default_branch)

        branch_name = f"bug-basher/{findings.bug.jira_key.lower()}"
        await github_client.create_branch(owner, repo_name, branch_name, head_sha)

        for fc in best.proposed_fix.files_changed:
            # Try to get existing file sha
            existing_sha: str | None = None
            try:
                _, existing_sha = await github_client.get_file_content(
                    owner, repo_name, fc.path, branch_name
                )
            except GitHubClientError:
                pass  # New file

            await github_client.update_file(
                owner,
                repo_name,
                fc.path,
                fc.diff,  # MVP: treat diff as new content
                f"fix({findings.bug.jira_key}): update {fc.path}",
                branch_name,
                sha=existing_sha,
            )

        title = format_pr_title(findings)
        body = format_pr_body(findings)
        pr = await github_client.create_pull_request(
            owner, repo_name, title, body, branch_name, default_branch
        )
        return pr.get("html_url")

    except GitHubClientError as e:
        logger.error("Failed to create PR: %s", e)
        return None


# ---------------------------------------------------------------------------
# Orchestrator
# ---------------------------------------------------------------------------


async def report_findings(
    findings: AggregatedFindings,
    repos: list[Repository],
    jira_client: JiraClient,
    github_client: GitHubClient | None = None,
    slack_client: SlackClient | None = None,
    slack_channel: str = "",
) -> str | None:
    """Execute all reporting actions. Returns PR URL or None."""
    pr_url: str | None = None

    # 1. Create PR if action warrants it
    if (
        findings.action
        and findings.action.action_type == "pr"
        and github_client is not None
    ):
        try:
            pr_url = await create_pr_from_findings(findings, repos, github_client)
        except Exception:
            logger.exception("PR creation failed")

    # 2. Always comment on JIRA
    try:
        comment = format_jira_comment(findings, pr_url)
        await jira_client.add_comment(findings.bug.jira_key, comment)
    except Exception:
        logger.exception("JIRA comment failed")

    # 3. Post to Slack if configured
    if slack_client and slack_channel:
        try:
            text, blocks = format_slack_message(findings, pr_url)
            await slack_client.post_message(slack_channel, text, blocks)
        except Exception:
            logger.exception("Slack notification failed")

    return pr_url
